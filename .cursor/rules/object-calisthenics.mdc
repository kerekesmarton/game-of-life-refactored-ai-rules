---
alwaysApply: false
---

# Object Calisthenics (Pragmatic Guidelines)

## High-Value Rules (Apply Consistently) ⭐⭐⭐⭐⭐

### Wrap All Primitives and Strings
- **Apply**: When primitives represent domain concepts
- **Examples**: Cell class instead of boolean, Position instead of (row, col)
- **Exception**: Simple counters and basic arithmetic can remain primitive
- **Guideline**: 2 primitives as parameters are OK, 3+ should consider wrapping

### First-Class Collections
- **Apply**: Wrap collections with domain-specific behavior
- **Examples**: Grid class wrapping 2D array with neighbor operations
- **Benefit**: Better encapsulation and domain modeling

### Keep Entities Small
- **Target**: 50 lines per class, 15 lines per method
- **Apply**: Extract when classes/methods grow beyond these limits
- **Exception**: Don't force artificial splits that hurt readability

### No Abbreviations
- **Apply**: Use clear, descriptive names
- **Examples**: `is_alive()` not `is_alv()`, `count_neighbors()` not `cnt_nbrs()`

## Medium-Value Rules (Apply When Beneficial) ⭐⭐⭐

### Only One Dot Per Line
- **Apply**: When it improves readability
- **Example**: `dog.Body.Tail.Wag()` → `dog.ExpressHappiness()`
- **Exception**: Don't create artificial methods just to avoid dots

### No Public Getters/Setters/Properties
- **Apply**: Encapsulate data access through behavior
- **Exception**: Simple data transfer objects may need getters
- **Guideline**: Prefer methods that express intent over simple accessors

## Low-Value Rules (Apply Selectively) ⭐⭐

### Only One Level of Indentation Per Method
- **Apply**: Only when it improves readability
- **Exception**: Don't create many tiny methods that hurt flow
- **Guideline**: Prefer early returns over deep nesting

### Don't Use the ELSE Keyword
- **Apply**: When it makes code clearer
- **Exception**: Sometimes else makes intent clearer than early returns
- **Guideline**: Use judgment based on readability

### Two Arguments Per Method
- **Target**: 0-2 parameters ideal, 3+ requires justification
- **Apply**: Extract objects when parameter lists grow
- **Exception**: Simple utility methods may need more parameters

## Questionable Rules (Avoid Strict Enforcement) ⭐

### No Classes with More Than Two Instance Variables
- **Cost**: Extremely high, can lead to "ravioli code"
- **Guideline**: Use as a warning sign, not a strict rule
- **Exception**: Domain objects naturally need more state

### Five Lines Per Method
- **Cost**: High, can create many small methods
- **Guideline**: Use 15 lines as a more practical limit
- **Exception**: Some methods naturally need more lines for clarity

## Pragmatic Application Strategy

1. **Start with High-Value Rules**: Focus on primitive obsession and first-class collections
2. **Apply Medium-Value Rules**: When they genuinely improve code clarity
3. **Use Low-Value Rules Sparingly**: Only when they improve readability
4. **Avoid Questionable Rules**: Don't sacrifice clarity for arbitrary constraints

## Cost-Benefit Analysis
- **High ROI**: Primitive wrapping, first-class collections, clear naming
- **Medium ROI**: Method extraction, encapsulation
- **Low ROI**: Strict line limits, artificial method splitting
- **Negative ROI**: Extreme decomposition that hurts readability

## Anti-Patterns to Avoid
- **Ravioli Code**: Too many tiny classes that hurt understanding
- **Artificial Methods**: Methods created just to satisfy rules
- **Over-Abstraction**: Creating complexity where simplicity is better
- **Rule Worship**: Following rules blindly without considering readability